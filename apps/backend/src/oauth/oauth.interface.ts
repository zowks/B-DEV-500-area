import {
    ApiBearerAuth,
    ApiExtraModels,
    ApiForbiddenResponse,
    ApiNoContentResponse,
    ApiNotFoundResponse,
    ApiOkResponse,
    ApiParam,
    ApiProperty,
    ApiQuery,
    ApiUnauthorizedResponse,
    ApiUnprocessableEntityResponse,
    getSchemaPath
} from "@nestjs/swagger";
import { User } from "../users/interfaces/user.interface";
import { JwtGuard } from "src/auth/guards/jwt.guard";
import {
    applyDecorators,
    Delete,
    ForbiddenException,
    Get,
    HttpCode,
    HttpStatus,
    UseGuards
} from "@nestjs/common";
import { Request } from "express";
import { OAuthDBService } from "./oauthDb.service";
import { hash } from "node:crypto";
import { Cache } from "cache-manager";
import { OAuthCallbackResponseDto } from "./dto/OAuthCallbackResponse.dto";

export class OAuthCredential {
    @ApiProperty({ description: "The ID of the Google OAuth authorization." })
    readonly id?: number;

    @ApiProperty({
        description: "The access token used to interact with the Google API."
    })
    readonly access_token: string;

    @ApiProperty({
        description: "The token used to refresh the access token once expired."
    })
    readonly refresh_token: string;

    @ApiProperty({
        description: "The date at which the access token will expire."
    })
    readonly expires_at: Date;

    @ApiProperty({
        description:
            "The scopes granted to the access token. It's a list of scope joined by spaces."
    })
    readonly scope: string;
}

export abstract class OAuthManager extends OAuthDBService {
    readonly OAUTH_TOKEN_URL: string;

    readonly OAUTH_REVOKE_URL: string;

    abstract getOAuthUrl(state: string, scope: string): string;

    abstract getCredentials(code: string): Promise<OAuthCredential>;

    abstract refreshCredential(
        oauthCredential: OAuthCredential
    ): Promise<OAuthCredential>;

    abstract revokeCredential(oauthCredential: OAuthCredential): Promise<void>;
}

export function OAuthController_getOAuthUrl(): MethodDecorator &
    ClassDecorator {
    return applyDecorators(
        UseGuards(JwtGuard),
        Get("/"),
        HttpCode(HttpStatus.OK),
        ApiBearerAuth("bearer"),
        ApiOkResponse({
            description:
                "Returns the OAuth2.0 URL to which the user will have to log in to the service."
        }),
        ApiUnauthorizedResponse({
            description:
                "This route is protected. The client must supply a Bearer token."
        }),
        ApiQuery({
            name: "scope",
            description:
                "The scopes required for the OAuth2.0 credential. It's a whitespace-joined string list.",
            example:
                "https://www.googleapis.com/auth/youtube.readonly https://www.googleapis.com/auth/youtubepartner https://www.googleapis.com/auth/youtube.force-ssl"
        }),
        ApiQuery({
            name: "redirect_uri",
            description:
                "The URI to which the user will be redirected once the authentication flow is successful.",
            example: "http://localhost:5173/dashboard"
        })
    );
}

export function OAuthController_callback(): MethodDecorator & ClassDecorator {
    return applyDecorators(
        UseGuards(JwtGuard),
        Get("/callback"),
        HttpCode(HttpStatus.OK),
        ApiBearerAuth("bearer"),
        ApiExtraModels(OAuthCallbackResponseDto),
        ApiOkResponse({
            description:
                "The auth flow has been completed successfully. Returns the URL to which the user must be redirected to.",
            schema: {
                $ref: getSchemaPath(OAuthCallbackResponseDto)
            }
        }),
        ApiForbiddenResponse({
            description:
                "The 'state' attribute stored in the user' session is either invalid or does not match the one returned by the OAuth provider. This may happen during a CSRF attack."
        }),
        ApiQuery({
            name: "code",
            description:
                "The 'code' query returned by the OAuth provider. It will be used as an exchange method for access and refresh tokens."
        }),
        ApiQuery({
            name: "state",
            description:
                "The 'state' query returned by the OAuth provider. It is a hash generated by the backend when requesting the OAuth URL for authorization. That query must appear in the OAuth provider's response in order to check for a potential CSRF attack and protect the user."
        })
    );
}

export function OAuthController_credentials(): MethodDecorator &
    ClassDecorator {
    return applyDecorators(
        UseGuards(JwtGuard),
        Get("/credentials"),
        ApiExtraModels(OAuthCredential),
        ApiBearerAuth("bearer"),
        ApiOkResponse({
            description:
                "Returns all the OAuth2.0 credentials related to the user.",
            schema: {
                $ref: getSchemaPath(OAuthCredential)
            }
        }),
        ApiUnauthorizedResponse({
            description:
                "This route is protected. The client must supply a Bearer token."
        })
    );
}

export function OAuthController_revoke(): MethodDecorator & ClassDecorator {
    return applyDecorators(
        UseGuards(JwtGuard),
        Delete("/revoke/:oauthCredentialId"),
        ApiParam({
            name: "oauthCredentialId",
            description: "The ID of the credential to revoke.",
            type: Number
        }),
        ApiBearerAuth("bearer"),
        ApiNoContentResponse({
            description: "Revokes an oauth credential."
        }),
        ApiNotFoundResponse({
            description:
                "The given credential ID was either not found or does not belong to the current user."
        }),
        ApiUnprocessableEntityResponse({
            description:
                "The given credential ID was found and belongs to the correct user, but it's OAuth provider is different from the current route provider.",
            example:
                "Unable to revoke the token. It may be from the wrong provider."
        }),
        ApiUnauthorizedResponse({
            description:
                "This route is protected. The client must supply a Bearer token."
        })
    );
}

export interface OAuthMetadata {
    state: string;
    requestedAt: number;
    redirectUri: string;
}

export abstract class OAuthController {
    static readonly OAUTH_METADATA_TTL: number = 600000; // 10 minutes

    static createState(userId: User["id"], requestedAt: number) {
        return hash("SHA-512", `${userId}:${requestedAt}`, "hex");
    }

    static async prepareOAuthSession(
        cacheManager: Cache,
        userId: User["id"],
        redirectUri: string
    ): Promise<string> {
        const requestedAt = Date.now();
        const state = OAuthController.createState(userId, requestedAt);

        const oauthMetadata: OAuthMetadata = {
            state,
            requestedAt,
            redirectUri
        };

        await cacheManager.set(
            `oauth-${userId}`,
            oauthMetadata,
            OAuthController.OAUTH_METADATA_TTL
        );

        return state;
    }

    static async verifyState(
        cacheManager: Cache,
        userId: User["id"],
        state: string
    ): Promise<string> {
        const oauthMetadata: OAuthMetadata = await cacheManager.get(
            `oauth-${userId}`
        );
        if (undefined === oauthMetadata)
            throw new ForbiddenException("Session expired.");
        await cacheManager.del(`oauth-${userId}`);
        if (state !== oauthMetadata.state)
            throw new ForbiddenException(
                "Invalid state. Possibly due to a CSRF attack attempt."
            );
        return oauthMetadata.redirectUri;
    }

    abstract getOAuthUrl(
        req: Request,
        scope: string,
        redirectUri: string
    ): Promise<{ redirect_uri: string }>;

    abstract callback(
        req: Request,
        code: string,
        state: string
    ): Promise<OAuthCallbackResponseDto>;

    abstract credentials(req: Request): Promise<OAuthCredential[]>;

    abstract revoke(
        req: Request,
        oauthCredentialId: OAuthCredential["id"]
    ): Promise<void>;
}
